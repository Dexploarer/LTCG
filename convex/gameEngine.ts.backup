/**
 * Game Engine
 *
 * Core gameplay mutations for Lunchtable TCG (Yu-Gi-Oh style mechanics).
 * Handles:
 * - Normal Summon / Tribute Summon
 * - Set Monster
 * - Flip Summon
 * - Position Change
 */

import { v } from "convex/values";
import { mutation } from "./_generated/server";
import type { Id } from "./_generated/dataModel";
import { api } from "./_generated/api";
import { getUserFromToken } from "./lib/auth";
import { moveCard, enforceHandLimit, clearTemporaryModifiers, clearOPTTracking } from "./lib/gameHelpers";
import { parseAbility, executeEffect } from "./effectSystem";
import {
  validateNormalSummon,
  validateSetMonster,
  validateFlipSummon,
  validatePositionChange,
} from "./summonValidator";

/**
 * Normal Summon a monster
 *
 * Summons a monster from hand to the field in face-up Attack or Defense Position.
 * Counts as the 1 Normal Summon per turn.
 * Records: normal_summon or tribute_summon (if tributes used)
 * Also records: tribute_paid, card_to_graveyard (if tributes)
 */
export const normalSummon = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
    tributeCardIds: v.optional(v.array(v.id("cardDefinitions"))),
    position: v.union(v.literal("attack"), v.literal("defense")),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    // 5. Validate summon
    const validation = await validateNormalSummon(
      ctx,
      gameState,
      user.userId,
      args.cardId,
      args.tributeCardIds
    );

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const isHost = user.userId === gameState.hostId;
    const hand = isHost ? gameState.hostHand : gameState.opponentHand;
    const board = isHost ? gameState.hostBoard : gameState.opponentBoard;

    // 6. Get card details
    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    // 7. Process tributes (if any)
    const tributeCount = args.tributeCardIds?.length || 0;
    if (tributeCount > 0 && args.tributeCardIds) {
      // Record tribute_paid event
      await ctx.runMutation(api.gameEvents.recordEvent, {
        lobbyId: args.lobbyId,
        gameId: lobby.gameId!,
        turnNumber: lobby.turnNumber!,
        eventType: "tribute_paid",
        playerId: user.userId,
        playerUsername: user.username,
        description: `${user.username} tributed ${tributeCount} monster(s)`,
        metadata: {
          tributeCards: args.tributeCardIds,
          forCard: args.cardId,
        },
      });

      // Move tributed monsters to graveyard
      for (const tributeId of args.tributeCardIds) {
        await moveCard(
          ctx,
          gameState,
          tributeId,
          "board",
          "graveyard",
          user.userId,
          lobby.turnNumber
        );

        // Remove from board
        const updatedBoard = board.filter((bc) => bc.cardId !== tributeId);
        await ctx.db.patch(gameState._id, {
          [isHost ? "hostBoard" : "opponentBoard"]: updatedBoard,
        });
      }
    }

    // 8. Remove card from hand
    const newHand = hand.filter((c) => c !== args.cardId);

    // 9. Add card to board (face-up normal summon)
    const positionValue = args.position === "attack" ? 1 : -1; // 1 = ATK, -1 = DEF

    // Parse ability for protection flags
    let protectionFlags = {};
    if (card.ability) {
      const parsedEffect = parseAbility(card.ability);
      if (parsedEffect?.protection) {
        protectionFlags = {
          cannotBeDestroyedByBattle: parsedEffect.protection.cannotBeDestroyedByBattle,
          cannotBeDestroyedByEffects: parsedEffect.protection.cannotBeDestroyedByEffects,
          cannotBeTargeted: parsedEffect.protection.cannotBeTargeted,
        };
      }
    }

    const newBoardCard = {
      cardId: args.cardId,
      position: positionValue,
      attack: card.attack || 0,
      defense: card.defense || 0,
      hasAttacked: false,
      isFaceDown: false, // Normal summon is face-up
      ...protectionFlags,
    };

    const newBoard = [...board, newBoardCard];

    // 10. Mark player as having normal summoned this turn
    await ctx.db.patch(gameState._id, {
      [isHost ? "hostHand" : "opponentHand"]: newHand,
      [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
      [isHost
        ? "hostNormalSummonedThisTurn"
        : "opponentNormalSummonedThisTurn"]: true,
    });

    // 11. Record summon event
    const eventType = tributeCount > 0 ? "tribute_summon" : "normal_summon";
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType,
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} ${tributeCount > 0 ? "Tribute" : "Normal"} Summoned ${card.name} in ${args.position} position`,
      metadata: {
        cardId: args.cardId,
        cardName: card.name,
        position: args.position,
        tributeCount,
        attack: card.attack,
        defense: card.defense,
      },
    });

    // 12. Check for "When summoned" trigger effects
    let triggerEffectResult = { success: true, message: "No trigger" };

    if (card.ability) {
      const parsedEffect = parseAbility(card.ability);

      // Only execute if this is an "on_summon" trigger
      if (parsedEffect && parsedEffect.trigger === "on_summon") {
        const refreshedState = await ctx.db
          .query("gameStates")
          .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
          .first();

        if (refreshedState) {
          triggerEffectResult = await executeEffect(
            ctx,
            refreshedState,
            args.lobbyId,
            parsedEffect,
            user.userId,
            args.cardId,
            [] // No targets for auto-trigger effects for now
          );

          if (triggerEffectResult.success) {
            // Record trigger activation
            await ctx.runMutation(api.gameEvents.recordEvent, {
              lobbyId: args.lobbyId,
              gameId: lobby.gameId!,
              turnNumber: lobby.turnNumber!,
              eventType: "effect_activated",
              playerId: user.userId,
              playerUsername: user.username,
              description: `${card.name} effect: ${triggerEffectResult.message}`,
              metadata: { cardId: args.cardId, trigger: "on_summon" },
            });
          }
        }
      }
    }

    // 13. Return success
    return {
      success: true,
      cardSummoned: card.name,
      position: args.position,
      tributesUsed: tributeCount,
      triggerEffect: triggerEffectResult.message,
    };
  },
});

/**
 * Set a monster face-down
 *
 * Places a monster from hand face-down in Defense Position.
 * Counts as the 1 Normal Summon per turn.
 * Records: monster_set
 */
export const setMonster = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
    tributeCardIds: v.optional(v.array(v.id("cardDefinitions"))),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    // 5. Validate set (uses same validation as normal summon)
    const validation = await validateSetMonster(
      ctx,
      gameState,
      user.userId,
      args.cardId,
      args.tributeCardIds
    );

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const isHost = user.userId === gameState.hostId;
    const hand = isHost ? gameState.hostHand : gameState.opponentHand;
    const board = isHost ? gameState.hostBoard : gameState.opponentBoard;

    // 6. Get card details
    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    // 7. Process tributes (if any)
    const tributeCount = args.tributeCardIds?.length || 0;
    if (tributeCount > 0 && args.tributeCardIds) {
      await ctx.runMutation(api.gameEvents.recordEvent, {
        lobbyId: args.lobbyId,
        gameId: lobby.gameId!,
        turnNumber: lobby.turnNumber!,
        eventType: "tribute_paid",
        playerId: user.userId,
        playerUsername: user.username,
        description: `${user.username} tributed ${tributeCount} monster(s)`,
        metadata: {
          tributeCards: args.tributeCardIds,
          forCard: args.cardId,
        },
      });

      for (const tributeId of args.tributeCardIds) {
        await moveCard(
          ctx,
          gameState,
          tributeId,
          "board",
          "graveyard",
          user.userId,
          lobby.turnNumber
        );

        const updatedBoard = board.filter((bc) => bc.cardId !== tributeId);
        await ctx.db.patch(gameState._id, {
          [isHost ? "hostBoard" : "opponentBoard"]: updatedBoard,
        });
      }
    }

    // 8. Remove card from hand
    const newHand = hand.filter((c) => c !== args.cardId);

    // 9. Add card to board (face-down defense position)
    const newBoardCard = {
      cardId: args.cardId,
      position: -1, // -1 = Defense
      attack: card.attack || 0,
      defense: card.defense || 0,
      hasAttacked: false,
      isFaceDown: true, // Set monsters are face-down
    };

    const newBoard = [...board, newBoardCard];

    // 10. Mark player as having normal summoned/set this turn
    await ctx.db.patch(gameState._id, {
      [isHost ? "hostHand" : "opponentHand"]: newHand,
      [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
      [isHost
        ? "hostNormalSummonedThisTurn"
        : "opponentNormalSummonedThisTurn"]: true,
    });

    // 11. Record monster_set event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "monster_set",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} Set a monster face-down`,
      metadata: {
        cardId: args.cardId,
        // Don't reveal card name for face-down cards
        tributeCount,
      },
    });

    // 12. Return success
    return {
      success: true,
      cardSet: "face-down",
      tributesUsed: tributeCount,
    };
  },
});

/**
 * Flip Summon a face-down monster
 *
 * Flips a face-down monster to face-up Attack or Defense Position.
 * Does NOT count as the Normal Summon.
 * Records: flip_summon
 */
export const flipSummon = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
    newPosition: v.union(v.literal("attack"), v.literal("defense")),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    // 5. Validate flip summon
    const validation = await validateFlipSummon(ctx, gameState, user.userId, args.cardId);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const isHost = user.userId === gameState.hostId;
    const board = isHost ? gameState.hostBoard : gameState.opponentBoard;

    // 6. Find card on board and flip it
    const cardIndex = board.findIndex((bc) => bc.cardId === args.cardId);
    if (cardIndex === -1) {
      throw new Error("Card not found on board");
    }

    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    // 7. Update card to face-up
    const positionValue = args.newPosition === "attack" ? 1 : -1; // 1 = ATK, -1 = DEF
    const newBoard = [...board];
    newBoard[cardIndex] = {
      ...newBoard[cardIndex]!,
      position: positionValue,
      isFaceDown: false, // Flip to face-up
    };

    await ctx.db.patch(gameState._id, {
      [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
    });

    // 8. Record flip_summon event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "flip_summon",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} Flip Summoned ${card.name} in ${args.newPosition} position`,
      metadata: {
        cardId: args.cardId,
        cardName: card.name,
        position: args.newPosition,
        attack: card.attack,
        defense: card.defense,
      },
    });

    // 9. Trigger FLIP effect if exists
    let flipEffectResult = { success: true, message: "No FLIP effect" };

    if (card.ability) {
      const parsedEffect = parseAbility(card.ability);

      // Only execute if this is an "on_flip" trigger
      if (parsedEffect && parsedEffect.trigger === "on_flip") {
        const refreshedState = await ctx.db
          .query("gameStates")
          .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
          .first();

        if (refreshedState) {
          flipEffectResult = await executeEffect(
            ctx,
            refreshedState,
            args.lobbyId,
            parsedEffect,
            user.userId,
            args.cardId,
            [] // No targets for auto-trigger effects for now
          );

          if (flipEffectResult.success) {
            // Record FLIP effect activation
            await ctx.runMutation(api.gameEvents.recordEvent, {
              lobbyId: args.lobbyId,
              gameId: lobby.gameId!,
              turnNumber: lobby.turnNumber!,
              eventType: "effect_activated",
              playerId: user.userId,
              playerUsername: user.username,
              description: `FLIP: ${card.name} effect: ${flipEffectResult.message}`,
              metadata: { cardId: args.cardId, trigger: "on_flip" },
            });
          }
        }
      }
    }

    // 10. Return success
    return {
      success: true,
      cardFlipped: card.name,
      position: args.newPosition,
      flipEffect: flipEffectResult.message,
    };
  },
});

/**
 * Change monster position (Attack ↔ Defense)
 *
 * Switches a face-up monster between Attack and Defense Position.
 * Can only be done once per monster per turn.
 * Cannot be done in Battle Phase.
 * Records: position_changed
 */
export const changePosition = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    // 5. Validate position change
    const validation = await validatePositionChange(ctx, gameState, user.userId, args.cardId);

    if (!validation.valid) {
      throw new Error(validation.error);
    }

    const isHost = user.userId === gameState.hostId;
    const board = isHost ? gameState.hostBoard : gameState.opponentBoard;

    // 6. Find card on board and toggle position
    const cardIndex = board.findIndex((bc) => bc.cardId === args.cardId);
    if (cardIndex === -1) {
      throw new Error("Card not found on board");
    }

    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    const boardCard = board[cardIndex]!;
    const currentPosition = boardCard.position;
    const newPosition = currentPosition === 1 ? -1 : 1; // Toggle: 1 (ATK) ↔ -1 (DEF)
    const newPositionName = newPosition === 1 ? "attack" : "defense";
    const oldPositionName = currentPosition === 1 ? "attack" : "defense";

    // 7. Update position (maintain face-up status)
    const newBoard = [...board];
    newBoard[cardIndex] = {
      ...boardCard,
      position: newPosition,
    };

    await ctx.db.patch(gameState._id, {
      [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
    });

    // 8. Record position_changed event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "position_changed",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} changed ${card.name} to ${newPositionName} position`,
      metadata: {
        cardId: args.cardId,
        cardName: card.name,
        previousPosition: oldPositionName,
        newPosition: newPositionName,
      },
    });

    // 9. Return success
    return {
      success: true,
      cardName: card.name,
      newPosition: newPositionName,
    };
  },
});

/**
 * Set Spell/Trap face-down
 *
 * Places a Spell or Trap card from hand face-down in the Spell/Trap Zone.
 * Records: spell_set or trap_set
 */
export const setSpellTrap = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    const isHost = user.userId === gameState.hostId;
    const hand = isHost ? gameState.hostHand : gameState.opponentHand;
    const spellTrapZone = isHost ? gameState.hostSpellTrapZone : gameState.opponentSpellTrapZone;

    // 5. Validate card is in hand
    if (!hand.includes(args.cardId)) {
      throw new Error("Card is not in your hand");
    }

    // 6. Get card details
    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    if (card.cardType !== "spell" && card.cardType !== "trap") {
      throw new Error("Card must be a spell or trap card");
    }

    // 7. Validate Spell/Trap Zone space (max 5)
    if (spellTrapZone.length >= 5) {
      throw new Error("Spell/Trap Zone is full (max 5 cards)");
    }

    // 8. Remove card from hand and add to spell/trap zone
    const newHand = hand.filter((c) => c !== args.cardId);
    const newSpellTrapZone = [...spellTrapZone, {
      cardId: args.cardId,
      isFaceDown: true,
      isActivated: false
    }];

    await ctx.db.patch(gameState._id, {
      [isHost ? "hostHand" : "opponentHand"]: newHand,
      [isHost ? "hostSpellTrapZone" : "opponentSpellTrapZone"]: newSpellTrapZone,
    });

    // 9. Record event
    const eventType = card.cardType === "spell" ? "spell_set" : "trap_set";
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType,
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} Set a ${card.cardType} card`,
      metadata: {
        cardId: args.cardId,
        // Don't reveal card name for face-down cards
      },
    });

    // 10. Return success
    return {
      success: true,
      cardType: card.cardType,
    };
  },
});

/**
 * Activate Spell card
 *
 * Activates a Spell card from hand or field.
 * For MVP, immediately resolves (no chain system yet).
 * Records: spell_activated
 */
export const activateSpell = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
    targets: v.optional(v.array(v.id("cardDefinitions"))),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn (or valid activation timing)
    // Note: Quick-Play spells can be activated on opponent's turn
    // For MVP, we'll only allow activation on your own turn

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    const isHost = user.userId === gameState.hostId;
    const hand = isHost ? gameState.hostHand : gameState.opponentHand;
    const spellTrapZone = isHost ? gameState.hostSpellTrapZone : gameState.opponentSpellTrapZone;

    // 5. Validate card is in hand or set on field
    const inHand = hand.includes(args.cardId);
    const inSpellTrapZone = spellTrapZone.some(st => st.cardId === args.cardId);

    if (!inHand && !inSpellTrapZone) {
      throw new Error("Card is not in your hand or spell/trap zone");
    }

    // 6. Get card details
    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    if (card.cardType !== "spell") {
      throw new Error("Card is not a spell card");
    }

    // 7. Validate phase (Main Phases only for Normal Spells)
    const currentPhase = gameState.currentPhase;
    if (currentPhase !== "main1" && currentPhase !== "main2") {
      throw new Error("Can only activate Normal Spells during Main Phase");
    }

    // 8. Remove card from hand or spell/trap zone
    if (inHand) {
      const newHand = hand.filter((c) => c !== args.cardId);
      await ctx.db.patch(gameState._id, {
        [isHost ? "hostHand" : "opponentHand"]: newHand,
      });
    } else {
      // Remove from spell/trap zone
      const newSpellTrapZone = spellTrapZone.filter(st => st.cardId !== args.cardId);
      await ctx.db.patch(gameState._id, {
        [isHost ? "hostSpellTrapZone" : "opponentSpellTrapZone"]: newSpellTrapZone,
      });
    }

    // 9. Record spell_activated event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "spell_activated",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} activated ${card.name}`,
      metadata: {
        cardId: args.cardId,
        cardName: card.name,
        targets: args.targets,
      },
    });

    // 10. Parse and execute effect
    let effectResult = { success: true, message: "No effect" };

    if (card.ability) {
      const parsedEffect = parseAbility(card.ability);

      if (parsedEffect) {
        // Refresh game state (may have changed during event recording)
        const refreshedState = await ctx.db
          .query("gameStates")
          .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
          .first();

        if (refreshedState) {
          effectResult = await executeEffect(
            ctx,
            refreshedState,
            args.lobbyId,
            parsedEffect,
            user.userId,
            args.cardId,
            args.targets
          );

          if (!effectResult.success) {
            // Effect failed - still consume the card
            console.warn(`Effect failed: ${effectResult.message}`);
          }
        }
      } else {
        console.warn(`Could not parse ability: ${card.ability}`);
      }
    }

    // 11. Move to graveyard
    const updatedState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (updatedState) {
      const graveyard = isHost ? updatedState.hostGraveyard : updatedState.opponentGraveyard;
      await ctx.db.patch(updatedState._id, {
        [isHost ? "hostGraveyard" : "opponentGraveyard"]: [...graveyard, args.cardId],
      });
    }

    // 12. Return success with effect result
    return {
      success: true,
      spellName: card.name,
      effectApplied: effectResult.success,
      effectMessage: effectResult.message,
    };
  },
});

/**
 * Activate Trap card
 *
 * Activates a face-down Trap card from field.
 * For MVP, immediately resolves (no chain system yet).
 * Records: trap_activated
 */
export const activateTrap = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
    cardId: v.id("cardDefinitions"),
    targets: v.optional(v.array(v.id("cardDefinitions"))),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    const isHost = user.userId === gameState.hostId;
    const spellTrapZone = isHost ? gameState.hostSpellTrapZone : gameState.opponentSpellTrapZone;

    // 4. Validate trap is set on field
    const trapInZone = spellTrapZone.find(st => st.cardId === args.cardId);
    if (!trapInZone) {
      throw new Error("Trap card is not set on your field");
    }

    if (!trapInZone.isFaceDown) {
      throw new Error("Trap is already face-up");
    }

    // 5. Get card details
    const card = await ctx.db.get(args.cardId);
    if (!card) {
      throw new Error("Card not found");
    }

    if (card.cardType !== "trap") {
      throw new Error("Card is not a trap card");
    }

    // 6. Validate trap was set for at least 1 turn
    // TODO: Track when cards were set, validate turn count
    // For now, we'll skip this validation

    // 7. Remove from spell/trap zone
    const newSpellTrapZone = spellTrapZone.filter(st => st.cardId !== args.cardId);
    await ctx.db.patch(gameState._id, {
      [isHost ? "hostSpellTrapZone" : "opponentSpellTrapZone"]: newSpellTrapZone,
    });

    // 8. Record trap_activated event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "trap_activated",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username} activated ${card.name}`,
      metadata: {
        cardId: args.cardId,
        cardName: card.name,
        targets: args.targets,
      },
    });

    // 9. Parse and execute effect
    let effectResult = { success: true, message: "No effect" };

    if (card.ability) {
      const parsedEffect = parseAbility(card.ability);

      if (parsedEffect) {
        // Refresh game state (may have changed during event recording)
        const refreshedState = await ctx.db
          .query("gameStates")
          .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
          .first();

        if (refreshedState) {
          effectResult = await executeEffect(
            ctx,
            refreshedState,
            args.lobbyId,
            parsedEffect,
            user.userId,
            args.cardId,
            args.targets
          );

          if (!effectResult.success) {
            console.warn(`Effect failed: ${effectResult.message}`);
          }
        }
      } else {
        console.warn(`Could not parse ability: ${card.ability}`);
      }
    }

    // 10. Move to graveyard
    const updatedState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (updatedState) {
      const graveyard = isHost ? updatedState.hostGraveyard : updatedState.opponentGraveyard;
      await ctx.db.patch(updatedState._id, {
        [isHost ? "hostGraveyard" : "opponentGraveyard"]: [...graveyard, args.cardId],
      });
    }

    // 11. Return success with effect result
    return {
      success: true,
      trapName: card.name,
      effectApplied: effectResult.success,
      effectMessage: effectResult.message,
    };
  },
});

/**
 * End Turn
 *
 * Ends the current player's turn and starts the next turn.
 * Must be in End Phase to call this.
 *
 * Records: turn_end, hand_limit_enforced, turn_start, phase_changed
 */
export const endTurn = mutation({
  args: {
    token: v.string(),
    lobbyId: v.id("gameLobbies"),
  },
  handler: async (ctx, args) => {
    // 1. Validate session
    const user = await getUserFromToken(ctx, args.token);
    if (!user) {
      throw new Error("Invalid session token");
    }

    // 2. Get lobby
    const lobby = await ctx.db.get(args.lobbyId);
    if (!lobby) {
      throw new Error("Lobby not found");
    }

    // 3. Validate it's the current player's turn
    if (lobby.currentTurnPlayerId !== user.userId) {
      throw new Error("Not your turn");
    }

    // 4. Get game state
    const gameState = await ctx.db
      .query("gameStates")
      .withIndex("by_lobby", (q) => q.eq("lobbyId", args.lobbyId))
      .first();

    if (!gameState) {
      throw new Error("Game state not found");
    }

    // 5. Validate in End Phase
    if (gameState.currentPhase !== "end") {
      throw new Error("Must be in End Phase to end turn");
    }

    const isHost = user.userId === gameState.hostId;

    // 6. Trigger end-of-turn effects (future implementation)

    // 7. Enforce hand size limit (6 cards max)
    await enforceHandLimit(ctx, gameState, user.userId, lobby.turnNumber);

    // 7.5. Clear temporary modifiers (ATK/DEF bonuses "until end of turn")
    await clearTemporaryModifiers(ctx, gameState, "end");

    // 7.6. Clear OPT (Once Per Turn) tracking
    await clearOPTTracking(ctx, gameState);

    // 8. Clear "this turn" flags
    const playerBoard = isHost ? gameState.hostBoard : gameState.opponentBoard;
    const opponentBoard = isHost ? gameState.opponentBoard : gameState.hostBoard;

    // Reset hasAttacked for all monsters
    const resetPlayerBoard = playerBoard.map((card) => ({
      ...card,
      hasAttacked: false,
    }));

    const resetOpponentBoard = opponentBoard.map((card) => ({
      ...card,
      hasAttacked: false,
    }));

    // 9. Record turn_end event
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: lobby.turnNumber!,
      eventType: "turn_end",
      playerId: user.userId,
      playerUsername: user.username,
      description: `${user.username}'s turn ended`,
      metadata: {
        turnNumber: lobby.turnNumber!,
      },
    });

    // 10. Switch to next player
    const nextPlayerId = isHost ? gameState.opponentId : gameState.hostId;
    const nextTurnNumber = lobby.turnNumber! + 1;

    await ctx.db.patch(args.lobbyId, {
      currentTurnPlayerId: nextPlayerId,
      turnNumber: nextTurnNumber,
    });

    // 11. Reset normal summon flags
    await ctx.db.patch(gameState._id, {
      [isHost ? "hostBoard" : "opponentBoard"]: resetPlayerBoard,
      [isHost ? "opponentBoard" : "hostBoard"]: resetOpponentBoard,
      hostNormalSummonedThisTurn: false,
      opponentNormalSummonedThisTurn: false,
      currentPhase: "draw",
    });

    // 12. Record turn_start event for new turn
    const nextPlayer = await ctx.db.get(nextPlayerId);
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: nextTurnNumber,
      eventType: "turn_start",
      playerId: nextPlayerId,
      playerUsername: nextPlayer?.username || "Unknown",
      description: `${nextPlayer?.username || "Unknown"}'s turn ${nextTurnNumber}`,
      metadata: {
        turnNumber: nextTurnNumber,
      },
    });

    // 13. Record phase_changed event (to Draw Phase)
    await ctx.runMutation(api.gameEvents.recordEvent, {
      lobbyId: args.lobbyId,
      gameId: lobby.gameId!,
      turnNumber: nextTurnNumber,
      eventType: "phase_changed",
      playerId: nextPlayerId,
      playerUsername: nextPlayer?.username || "Unknown",
      description: `${nextPlayer?.username || "Unknown"} entered Draw Phase`,
      metadata: {
        previousPhase: "end",
        newPhase: "draw",
      },
    });

    // 14. Auto-execute Draw Phase (skip on turn 1 for first player)
    const shouldSkipDraw = nextTurnNumber === 1 && nextPlayerId === lobby.hostId;
    if (!shouldSkipDraw) {
      // Note: drawCards is called via phaseManager.initializeTurnPhase
      // For now, we'll leave this to be handled by phase manager
    }

    // 15. Return success
    return {
      success: true,
      newTurnPlayer: nextPlayer?.username || "Unknown",
      newTurnNumber: nextTurnNumber,
    };
  },
});
