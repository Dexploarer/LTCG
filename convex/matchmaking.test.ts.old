import { expect, test, describe } from "vitest";
import { createTestInstance } from "./test_utils/setup";
import type { TestMutationCtx } from "./test_utils/setup";
import { api } from "./_generated/api";

describe("Matchmaking System", () => {
  test("getMyStatus returns null when not in queue", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      return await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });
    });

    const asUser = t.withIdentity({ subject: userId });
    const status = await asUser.query(api.matchmaking.getMyStatus, {});

    expect(status!).toBeNull();
  });

  test("joinQueue adds player to queue", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });

      const deck = await ctx.db.insert("userDecks", {
        userId: uid,
        name: "Fire Deck",
        deckArchetype: "fire",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });

      await ctx.db.patch(uid, { activeDeckId: deck });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });

    await asUser.mutation(api.matchmaking.joinQueue, {
      mode: "ranked",
      deckArchetype: "fire",
    });

    const status = await asUser.query(api.matchmaking.getMyStatus, {});

    expect(status?.status).toBe("searching");
    expect(status?.mode).toBe("ranked");
  });

  test("leaveQueue removes player from queue", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });

      const deck = await ctx.db.insert("userDecks", {
        userId: uid,
        name: "Fire Deck",
        deckArchetype: "fire",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });

      await ctx.db.patch(uid, { activeDeckId: deck });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });

    await asUser.mutation(api.matchmaking.joinQueue, {
      mode: "ranked",
      deckArchetype: "fire",
    });

    await asUser.mutation(api.matchmaking.leaveQueue, {});

    const status = await asUser.query(api.matchmaking.getMyStatus, {});

    expect(status!).toBeNull();
  });

  test("cannot join queue without active deck", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      return await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });
    });

    const asUser = t.withIdentity({ subject: userId });

    await expect(
      asUser.mutation(api.matchmaking.joinQueue, {
        mode: "ranked",
        deckArchetype: "fire",
      })
    ).rejects.toThrowError(/No active deck/);
  });

  test("cannot join queue while already in queue", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });

      const deck = await ctx.db.insert("userDecks", {
        userId: uid,
        name: "Deck",
        deckArchetype: "fire",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });

      await ctx.db.patch(uid, { activeDeckId: deck });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });

    await asUser.mutation(api.matchmaking.joinQueue, {
      mode: "ranked",
      deckArchetype: "fire",
    });

    await expect(
      asUser.mutation(api.matchmaking.joinQueue, {
        mode: "ranked",
        deckArchetype: "fire",
      })
    ).rejects.toThrowError(/Already in queue/);
  });

  test("getQueueStats returns stats", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "player1",
        email: "player1@test.com",
        rankedElo: 1000,
        casualRating: 1000,
        totalWins: 0,
        totalLosses: 0,
        createdAt: Date.now(),
      });

      const deck = await ctx.db.insert("userDecks", {
        userId: uid,
        name: "Deck",
        deckArchetype: "fire",
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });

      await ctx.db.patch(uid, { activeDeckId: deck });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });

    await asUser.mutation(api.matchmaking.joinQueue, {
      mode: "ranked",
      deckArchetype: "fire",
    });

    const stats = await t.query(api.matchmaking.getQueueStats, {});

    expect(stats.totalPlayers).toBe(1);
    expect(stats.byMode.ranked).toBe(1);
    expect(stats.byMode.casual).toBe(0);
  });
});
