/**
 * Card Effect System
 *
 * Parses ability strings and executes card effects.
 * Handles triggers, targeting, costs, and effect resolution.
 */

import { v } from "convex/values";
import type { Id, Doc } from "./_generated/dataModel";
import type { MutationCtx } from "./_generated/server";
import { mutation, internalMutation } from "./_generated/server";
import { api } from "./_generated/api";
import { hasUsedOPT, markOPTUsed } from "./lib/gameHelpers";

// ============================================================================
// EFFECT TYPES
// ============================================================================

export type EffectType =
  | "draw"           // Draw X cards
  | "destroy"        // Destroy target card(s)
  | "damage"         // Deal X damage to player
  | "gainLP"         // Gain X LP
  | "modifyATK"      // Modify ATK/DEF
  | "summon"         // Special summon
  | "toHand"         // Add card to hand
  | "toGraveyard"    // Send card to GY
  | "banish"         // Banish card
  | "search"         // Search deck
  | "negate"         // Negate activation/effect

export type TriggerCondition =
  | "on_summon"            // When this card is summoned
  | "on_destroy"           // When this card is destroyed
  | "on_flip"              // When this card is flipped
  | "on_battle_damage"     // When this card inflicts battle damage
  | "on_battle_destroy"    // When this card destroys a monster by battle
  | "on_battle_attacked"   // When this card is attacked
  | "on_battle_start"      // At the start of the Battle Phase
  | "on_draw"              // During draw phase
  | "on_end"               // During end phase
  | "manual"               // Manual activation (spells/traps)

export interface ParsedEffect {
  type: EffectType;
  trigger: TriggerCondition;
  value?: number;                              // Numeric value (e.g., "Draw 2" -> value: 2)
  targetCount?: number;                        // Number of targets required
  targetType?: "monster" | "spell" | "trap" | "any";
  targetLocation?: "board" | "hand" | "graveyard" | "deck";
  condition?: string;                          // Additional conditions
  continuous?: boolean;                        // Is this a continuous effect?
  isOPT?: boolean;                             // Once per turn restriction
  // Cost field for effects that require payment
  cost?: {
    type: "discard" | "pay_lp" | "tribute" | "banish";
    value?: number;                            // Number of cards or LP amount
    targetType?: "monster" | "spell" | "trap" | "any";
  };
  // Protection flags
  protection?: {
    cannotBeDestroyedByBattle?: boolean;
    cannotBeDestroyedByEffects?: boolean;
    cannotBeTargeted?: boolean;
  };
}

// Multi-part ability support
export interface ParsedAbility {
  effects: ParsedEffect[];
  hasMultiPart: boolean;
}

// ============================================================================
// ABILITY PARSER
// ============================================================================

/**
 * Parse ability string into structured effect data
 *
 * Examples:
 * - "Draw 2 cards" -> { type: "draw", value: 2, trigger: "manual" }
 * - "Destroy 1 target monster" -> { type: "destroy", targetCount: 1, targetType: "monster" }
 * - "When summoned: Draw 1 card" -> { type: "draw", value: 1, trigger: "on_summon" }
 * - "Gain 500 LP" -> { type: "gainLP", value: 500 }
 */
export function parseAbility(abilityText: string): ParsedEffect | null {
  if (!abilityText || abilityText.trim() === "") {
    return null;
  }

  const text = abilityText.toLowerCase().trim();
  let trigger: TriggerCondition = "manual";

  // Detect Once Per Turn (OPT) restriction
  const isOPT = text.includes("once per turn");

  // Detect protection effects
  const protection: { cannotBeDestroyedByBattle?: boolean; cannotBeDestroyedByEffects?: boolean; cannotBeTargeted?: boolean; } = {};

  // Check for combined protection: "cannot be destroyed by battle or card effects"
  if (text.includes("cannot be destroyed by battle or card effects") ||
      text.includes("cannot be destroyed by battle or effect")) {
    protection.cannotBeDestroyedByBattle = true;
    protection.cannotBeDestroyedByEffects = true;
  } else {
    // Check individual protections
    if (text.includes("cannot be destroyed by battle")) {
      protection.cannotBeDestroyedByBattle = true;
    }
    if (text.includes("cannot be destroyed by card effects") || text.includes("cannot be destroyed by effect")) {
      protection.cannotBeDestroyedByEffects = true;
    }
  }

  if (text.includes("cannot be targeted by") && text.includes("opponent")) {
    protection.cannotBeTargeted = true;
  }
  const hasProtection = Object.keys(protection).length > 0;

  // Detect continuous effects
  const isContinuous = text.startsWith("all ") || text.includes("as long as") ||
                       text.includes("while this card is on the field") ||
                       (!text.includes("when") && !text.includes("if") &&
                        (text.includes("gain") && text.includes("atk")) ||
                        (text.includes("lose") && text.includes("atk")));

  // Detect trigger condition
  // Check more specific patterns first to avoid false matches
  if (text.includes("when") || text.includes("if") || text.includes("during") || text.includes("at the start")) {
    if (text.includes("summon")) trigger = "on_summon";
    else if (text.includes("flip")) trigger = "on_flip";
    // Battle-specific triggers (check before generic destroy)
    else if (text.includes("inflicts battle damage") || text.includes("inflict battle damage")) trigger = "on_battle_damage";
    else if (text.includes("destroys a monster by battle") || text.includes("destroy") && text.includes("by battle")) trigger = "on_battle_destroy";
    else if (text.includes("is attacked") || text.includes("this card is attacked")) trigger = "on_battle_attacked";
    // Generic destroy (after battle-specific checks)
    else if (text.includes("destroy") && !text.includes("battle")) trigger = "on_destroy";
    // Phase triggers
    else if (text.includes("start of the battle phase") || text.includes("battle phase") && text.includes("start")) trigger = "on_battle_start";
    else if (text.includes("draw phase")) trigger = "on_draw";
    else if (text.includes("end phase") || text.includes("during each end phase")) trigger = "on_end";
  }

  // Detect cost patterns on original text BEFORE stripping
  // Costs typically appear before the effect: "Discard 1 card, then Draw 2 cards"
  // Or with a colon: "Pay 1000 LP: Draw 1 card"
  let cost: { type: "discard" | "pay_lp" | "tribute" | "banish"; value?: number; targetType?: "monster" | "spell" | "trap" | "any" } | undefined;
  let costStrippedText = text;

  // Pattern: "Discard X card(s)" or "Discard X monster(s)"
  const discardMatch = text.match(/discard (\d+) (monster|spell|trap|card)s?/i);
  if (discardMatch) {
    cost = {
      type: "discard",
      value: parseInt(discardMatch[1]),
      targetType: discardMatch[2].toLowerCase() === "card" ? "any" : discardMatch[2].toLowerCase() as "monster" | "spell" | "trap"
    };
    // Remove cost from text (everything before "then" or ":")
    costStrippedText = text.replace(/^.*?(?:,?\s*then\s*|:\s*)/i, "").trim();
  }

  // Pattern: "Pay X LP"
  const payLPMatch = text.match(/pay (\d+) lp/i);
  if (payLPMatch) {
    cost = {
      type: "pay_lp",
      value: parseInt(payLPMatch[1])
    };
    costStrippedText = text.replace(/^.*?(?:,?\s*then\s*|:\s*)/i, "").trim();
  }

  // Pattern: "Tribute X monster(s)"
  const tributeMatch = text.match(/tribute (\d+) (monster|card)s?/i);
  if (tributeMatch) {
    cost = {
      type: "tribute",
      value: parseInt(tributeMatch[1]),
      targetType: tributeMatch[2].toLowerCase() === "card" ? "any" : "monster"
    };
    costStrippedText = text.replace(/^.*?(?:,?\s*then\s*|:\s*)/i, "").trim();
  }

  // Pattern: "Banish X card(s)" (only if followed by "then" or ":")
  const banishCostMatch = text.match(/banish (\d+) (monster|spell|trap|card)s?/i);
  if (banishCostMatch && (text.includes(", then") || text.match(/banish.*:/))) {
    cost = {
      type: "banish",
      value: parseInt(banishCostMatch[1]),
      targetType: banishCostMatch[2].toLowerCase() === "card" ? "any" : banishCostMatch[2].toLowerCase() as "monster" | "spell" | "trap"
    };
    costStrippedText = text.replace(/^.*?(?:,?\s*then\s*|:\s*)/i, "").trim();
  }

  // Extract effect text (remove trigger prefix and OPT prefix) from cost-stripped text
  let effectText = costStrippedText.split(":").pop()?.trim() || costStrippedText;
  // Remove "once per turn" from effect text
  effectText = effectText.replace(/once per turn[,:]?\s*/g, "").trim();

  // If only protection effects (no other parseable effects), return protection-only effect
  // Use more precise patterns to avoid matching "destroyed" in "cannot be destroyed"
  const hasActionEffect = effectText.match(/\bdraw \d+|\bdestroy \d+|\bdeal \d+|\binflict \d+|\bgain \d+|\blose \d+|special summon|search .*deck|add .*(?:deck|graveyard)|banish/);
  if (hasProtection && !hasActionEffect) {
    return {
      type: "modifyATK", // Use modifyATK as a dummy type for protection-only
      trigger: "manual",
      value: 0,
      continuous: true, // Protection is always active
      isOPT: false,
      protection,
    };
  }

  // Parse Continuous Stat Modifier effects
  // Example: "All Dragon-Type monsters you control gain 300 ATK"
  // Example: "All monsters your opponent controls lose 200 ATK"
  // Example: "All Dragon-Type monsters gain an additional 200 ATK"
  if (isContinuous) {
    // Enhanced pattern with optional modifier words (additional, extra, bonus, etc.)
    const continuousAtkMatch = effectText.match(/all\s+(\w+(?:-type)?)\s+monsters?\s+(?:you control|your opponent controls)\s+(gains?|loses?)\s+(?:an?\s+)?(?:additional|extra|bonus)?\s*(\d+)\s+atk/i);
    if (continuousAtkMatch) {
      const archetype = continuousAtkMatch[1].toLowerCase();
      const gainOrLose = continuousAtkMatch[2].toLowerCase();
      const value = parseInt(continuousAtkMatch[3]);
      const isOpponent = effectText.includes("opponent");

      return {
        type: "modifyATK",
        trigger: "manual",
        value: gainOrLose.startsWith("lose") ? -value : value,
        continuous: true,
        isOPT: false,
        condition: isOpponent ? "opponent_monsters" : `${archetype}_monsters`,
      };
    }

    // Simpler pattern: "All X monsters gain Y ATK" with optional modifiers
    const simpleAtkMatch = effectText.match(/all\s+(\w+(?:-type)?)\s+monsters?\s+(gains?|loses?)\s+(?:an?\s+)?(?:additional|extra|bonus)?\s*(\d+)\s+atk/i);
    if (simpleAtkMatch) {
      const archetype = simpleAtkMatch[1].toLowerCase();
      const gainOrLose = simpleAtkMatch[2].toLowerCase();
      const value = parseInt(simpleAtkMatch[3]);

      return {
        type: "modifyATK",
        trigger: "manual",
        value: gainOrLose.startsWith("lose") ? -value : value,
        continuous: true,
        isOPT: false,
        condition: `${archetype}_monsters`,
      };
    }
  }

  // Parse Draw effects
  const drawMatch = effectText.match(/draw (\d+) card/);
  if (drawMatch) {
    return {
      type: "draw",
      trigger,
      value: parseInt(drawMatch[1]),
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Negation (check before destroy to avoid false matches)
  // Examples: "Negate the activation of a spell card"
  //           "Negate the effect of a trap card"
  //           "Negate the activation and destroy it"
  if (effectText.includes("negate")) {
    let targetType: "monster" | "spell" | "trap" | "any" = "any";

    // Detect target type
    if (effectText.includes("spell")) {
      targetType = "spell";
    } else if (effectText.includes("trap")) {
      targetType = "trap";
    } else if (effectText.includes("monster") || effectText.includes("effect")) {
      targetType = "monster";
    }

    // Detect if it's activation negation or effect negation
    const isActivationNegate = effectText.includes("activation");

    return {
      type: "negate",
      trigger,
      targetCount: 1,
      targetType,
      condition: isActivationNegate ? "activation" : "effect",
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Destroy effects
  const destroyMatch = effectText.match(/destroy (\d+)?\s*(target)?\s*(monster|spell|trap|card)?/);
  if (destroyMatch || effectText.includes("destroy")) {
    const targetCount = destroyMatch?.[1] ? parseInt(destroyMatch[1]) : 1;
    const targetType = (destroyMatch?.[3] as "monster" | "spell" | "trap") || "monster";

    return {
      type: "destroy",
      trigger,
      targetCount,
      targetType,
      targetLocation: "board",
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Damage effects
  const damageMatch = effectText.match(/(?:deal|inflict)\s*(\d+)\s*(?:damage|lp)?/);
  if (damageMatch) {
    return {
      type: "damage",
      trigger,
      value: parseInt(damageMatch[1]),
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse ATK/DEF modification (check before LP to avoid false matches)
  // Supports: "gains 500 ATK", "gains an additional 500 ATK", "gains an extra 500 ATK"
  const atkMatch = effectText.match(/(gains?|loses?)\s+(?:an?\s+)?(?:additional|extra|bonus)?\s*(\d+)\s*atk/);
  if (atkMatch) {
    const value = parseInt(atkMatch[2]);
    return {
      type: "modifyATK",
      trigger,
      value: atkMatch[1].startsWith("lose") ? -value : value,
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Gain LP effects
  const gainLPMatch = effectText.match(/(?:gains?|recovers?)\s*(\d+)\s*(?:lp|life points)?/);
  if (gainLPMatch) {
    return {
      type: "gainLP",
      trigger,
      value: parseInt(gainLPMatch[1]),
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Add from Graveyard to Hand
  // Example: "Add 1 Dragon monster from your graveyard to your hand"
  if ((effectText.includes("add") || effectText.includes("return")) &&
      (effectText.includes("graveyard") || effectText.includes("gy")) &&
      effectText.includes("hand")) {
    const countMatch = effectText.match(/(\d+)/);
    const targetCount = countMatch ? parseInt(countMatch[1]) : 1;

    // Detect target type from text
    let targetType: "monster" | "spell" | "trap" | "any" = "any";
    if (effectText.includes("monster")) targetType = "monster";
    else if (effectText.includes("spell")) targetType = "spell";
    else if (effectText.includes("trap")) targetType = "trap";

    return {
      type: "toHand",
      trigger,
      targetLocation: "graveyard",
      targetCount,
      targetType,
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Special Summon
  if (effectText.includes("special summon")) {
    const fromGY = effectText.includes("from") && effectText.includes("graveyard");
    return {
      type: "summon",
      trigger,
      targetLocation: fromGY ? "graveyard" : "hand",
      targetCount: 1,
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Return to Hand effects
  // Example: "Return 1 card to their hand"
  if (effectText.includes("return") && effectText.includes("hand") && !effectText.includes("graveyard")) {
    const countMatch = effectText.match(/(\d+)/);
    const targetCount = countMatch ? parseInt(countMatch[1]) : 1;

    return {
      type: "toHand",
      trigger,
      targetLocation: "board",
      targetCount,
      targetType: "any",
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Return to Deck effects
  // Example: "Return 1 card to their deck"
  if (effectText.includes("return") && effectText.includes("deck")) {
    const countMatch = effectText.match(/(\d+)/);
    const targetCount = countMatch ? parseInt(countMatch[1]) : 1;

    return {
      type: "toGraveyard", // Using toGraveyard type temporarily for deck returns
      trigger,
      targetLocation: "deck",
      targetCount,
      targetType: "any",
      isOPT,
    };
  }

  // Parse Search effects
  // Examples: "Add 1 Dragon monster from your deck to your hand"
  //           "Search your deck for 1 Spell card and add it to your hand"
  if (effectText.includes("search") || (effectText.includes("add") && effectText.includes("deck"))) {
    const countMatch = effectText.match(/(\d+)/);
    const targetCount = countMatch ? parseInt(countMatch[1]) : 1;

    // Detect target type
    let targetType: "monster" | "spell" | "trap" | "any" = "any";
    if (effectText.includes("monster")) targetType = "monster";
    else if (effectText.includes("spell")) targetType = "spell";
    else if (effectText.includes("trap")) targetType = "trap";

    // Detect archetype (e.g., "Dragon monster", "Fire-Type", etc.)
    let condition: string | undefined;
    const archetypePatterns = [
      /(\w+(?:-type)?)\s+monster/i,
      /(\w+)\s+(?:spell|trap)/i,
    ];

    for (const pattern of archetypePatterns) {
      const match = effectText.match(pattern);
      if (match && match[1]) {
        const archetype = match[1].toLowerCase();
        // Filter out generic words
        if (!["a", "an", "the", "any", "target"].includes(archetype)) {
          condition = `${archetype}_search`;
          break;
        }
      }
    }

    return {
      type: "search",
      trigger,
      targetCount,
      targetType,
      targetLocation: "deck",
      condition,
      isOPT,
      ...(cost && { cost }),
    };
  }

  // Parse Banish
  if (effectText.includes("banish") || effectText.includes("remove from play")) {
    return {
      type: "banish",
      trigger,
      targetCount: 1,
      targetLocation: "board",
      isOPT,
    };
  }

  // Couldn't parse - return null
  console.warn(`Could not parse ability: ${abilityText}`);
  return null;
}

/**
 * Parse multi-part ability into array of effects
 *
 * Handles complex abilities like:
 * - "Cannot be destroyed by battle. All Dragon-Type monsters gain 500 ATK. Once per turn: Draw 1 card."
 * - "Gain 500 ATK until end of turn. When this card destroys a monster by battle: Draw 1 card."
 *
 * Splits ability into clauses and parses each separately.
 */
export function parseMultiPartAbility(abilityText: string): ParsedAbility {
  if (!abilityText || abilityText.trim() === "") {
    return { effects: [], hasMultiPart: false };
  }

  const text = abilityText.trim();

  // Split by periods, but preserve trigger patterns (e.g., "When X: Do Y.")
  // Use a more sophisticated split that respects sentence structure
  const clauses: string[] = [];
  let currentClause = "";
  let depth = 0; // Track nesting level for colons

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    currentClause += char;

    if (char === ':') {
      depth++;
    } else if (char === '.' && depth === 0) {
      // Period outside of a trigger clause - this is a real separator
      if (currentClause.trim().length > 0) {
        clauses.push(currentClause.trim());
        currentClause = "";
      }
    } else if (char === '.' && depth > 0) {
      // Period inside trigger clause - reset depth after completing the triggered effect
      depth = 0;
      if (currentClause.trim().length > 0) {
        clauses.push(currentClause.trim());
        currentClause = "";
      }
    }
  }

  // Add remaining clause
  if (currentClause.trim().length > 0) {
    clauses.push(currentClause.trim());
  }

  // Parse each clause
  const effects: ParsedEffect[] = [];
  for (const clause of clauses) {
    const parsed = parseAbility(clause);
    if (parsed) {
      effects.push(parsed);
    }
  }

  return {
    effects,
    hasMultiPart: effects.length > 1,
  };
}

/**
 * Backwards-compatible wrapper for parseAbility that returns first effect from multi-part parse
 * This maintains compatibility with existing code while enabling multi-part parsing
 */
export function parseSingleAbility(abilityText: string): ParsedEffect | null {
  const parsed = parseMultiPartAbility(abilityText);
  return parsed.effects.length > 0 ? parsed.effects[0] : null;
}

// ============================================================================
// EFFECT EXECUTOR
// ============================================================================

/**
 * Execute a parsed effect
 */
export async function executeEffect(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  effect: ParsedEffect,
  playerId: Id<"users">,
  cardId: Id<"cardDefinitions">,
  targets?: Id<"cardDefinitions">[]
): Promise<{ success: boolean; message: string }> {

  // Check OPT restriction
  if (effect.isOPT && hasUsedOPT(gameState, cardId)) {
    return { success: false, message: "This card's effect can only be used once per turn" };
  }

  const isHost = playerId === gameState.hostId;
  const opponentId = isHost ? gameState.opponentId : gameState.hostId;

  // Check targeting protection for effects that target cards
  if (targets && targets.length > 0) {
    // Check both boards for targeted cards
    const hostBoard = gameState.hostBoard;
    const opponentBoard = gameState.opponentBoard;

    for (const targetId of targets) {
      const targetCard = [...hostBoard, ...opponentBoard].find(bc => bc.cardId === targetId);
      if (targetCard?.cannotBeTargeted) {
        const card = await ctx.db.get(targetId);
        return {
          success: false,
          message: `${card?.name || "Card"} cannot be targeted`
        };
      }
    }
  }

  // Execute the effect and capture result
  let result: { success: boolean; message: string };

  switch (effect.type) {
    case "draw":
      result = await executeDraw(ctx, gameState, playerId, effect.value || 1);
      break;

    case "destroy":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else if (effect.targetCount && effect.targetCount > 1) {
        // Multi-target destroy (e.g., "Destroy 2 target monsters")
        const destroyResults: string[] = [];
        let allSucceeded = true;

        for (let i = 0; i < Math.min(effect.targetCount, targets.length); i++) {
          const destroyResult = await executeDestroy(ctx, gameState, lobbyId, targets[i], playerId);
          destroyResults.push(destroyResult.message);
          if (!destroyResult.success) {
            allSucceeded = false;
          }
        }

        result = {
          success: allSucceeded,
          message: destroyResults.join("; ")
        };
      } else {
        // Single target destroy
        result = await executeDestroy(ctx, gameState, lobbyId, targets[0], playerId);
      }
      break;

    case "damage":
      result = await executeDamage(ctx, gameState, lobbyId, opponentId, effect.value || 0);
      break;

    case "gainLP":
      result = await executeGainLP(ctx, gameState, lobbyId, playerId, effect.value || 0);
      break;

    case "modifyATK":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else {
        result = await executeModifyATK(ctx, gameState, targets[0], effect.value || 0, isHost);
      }
      break;

    case "summon":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else {
        result = await executeSpecialSummon(ctx, gameState, targets[0], playerId, effect.targetLocation || "hand");
      }
      break;

    case "toHand":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else {
        result = await executeToHand(ctx, gameState, lobbyId, targets[0], playerId, effect.targetLocation || "graveyard");
      }
      break;

    case "search":
      // Search deck for cards matching criteria
      // Note: In a real implementation, this would require a two-step process:
      // 1. Call executeSearch without selectedCardId to get matching cards
      // 2. Present choices to player
      // 3. Call executeSearch again with selectedCardId to add to hand
      // For now, we'll return the matching cards for UI selection
      result = await executeSearch(ctx, gameState, playerId, effect, targets?.[0]);
      break;

    case "negate":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected for negation" };
      } else {
        result = await executeNegate(ctx, gameState, targets[0], effect);
      }
      break;

    case "toGraveyard":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else {
        // Filter targetLocation to valid source locations for sending to GY
        const validLocation = (effect.targetLocation === "board" ||
                                effect.targetLocation === "hand" ||
                                effect.targetLocation === "deck")
          ? effect.targetLocation
          : "board";

        result = await executeSendToGraveyard(
          ctx,
          gameState,
          lobbyId,
          targets[0],
          playerId,
          validLocation
        );
      }
      break;

    case "banish":
      if (!targets || targets.length === 0) {
        result = { success: false, message: "No targets selected" };
      } else {
        result = await executeBanish(
          ctx,
          gameState,
          targets[0],
          playerId,
          effect.targetLocation || "board"
        );
      }
      break;

    default:
      result = { success: false, message: `Unknown effect type: ${effect.type}` };
  }

  // Mark card as having used OPT effect if successful
  if (result.success && effect.isOPT) {
    await markOPTUsed(ctx, gameState, cardId);
  }

  return result;
}

/**
 * Execute all effects from a multi-part ability
 *
 * For cards with multiple effects (protection + continuous + triggered):
 * - Protection effects are passive (just flags)
 * - Continuous effects are calculated dynamically
 * - Triggered effects execute based on trigger condition
 *
 * Returns combined results from all executed effects
 */
export async function executeMultiPartAbility(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  parsedAbility: ParsedAbility,
  playerId: Id<"users">,
  cardId: Id<"cardDefinitions">,
  targets?: Id<"cardDefinitions">[]
): Promise<{ success: boolean; messages: string[]; effectsExecuted: number }> {
  const messages: string[] = [];
  let effectsExecuted = 0;
  let anySuccess = false;

  for (const effect of parsedAbility.effects) {
    // Skip protection-only effects (these are passive flags, not executed)
    if (effect.type === "modifyATK" && effect.value === 0 && effect.protection) {
      continue;
    }

    // Skip continuous effects (these are calculated dynamically, not executed)
    if (effect.continuous && effect.type === "modifyATK") {
      continue;
    }

    // Execute triggered or manual effects
    const result = await executeEffect(ctx, gameState, lobbyId, effect, playerId, cardId, targets);
    if (result.success) {
      anySuccess = true;
      effectsExecuted++;
    }
    messages.push(result.message);
  }

  return {
    success: anySuccess,
    messages,
    effectsExecuted,
  };
}

// ============================================================================
// INDIVIDUAL EFFECT IMPLEMENTATIONS
// ============================================================================

async function executeDraw(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  playerId: Id<"users">,
  count: number
): Promise<{ success: boolean; message: string }> {

  const isHost = playerId === gameState.hostId;
  const deck = isHost ? gameState.hostDeck : gameState.opponentDeck;
  const hand = isHost ? gameState.hostHand : gameState.opponentHand;

  // Check if enough cards in deck
  if (deck.length < count) {
    // Deck out - game loss
    return { success: false, message: "Not enough cards in deck (deck out)" };
  }

  // Draw cards
  const drawnCards = deck.slice(0, count);
  const newDeck = deck.slice(count);
  const newHand = [...hand, ...drawnCards];

  await ctx.db.patch(gameState._id, {
    [isHost ? "hostDeck" : "opponentDeck"]: newDeck,
    [isHost ? "hostHand" : "opponentHand"]: newHand,
  });

  return { success: true, message: `Drew ${count} card(s)` };
}

async function executeDestroy(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">
): Promise<{ success: boolean; message: string }> {

  const isHost = playerId === gameState.hostId;

  // Check both boards for target
  const hostBoard = gameState.hostBoard;
  const opponentBoard = gameState.opponentBoard;

  const onHostBoard = hostBoard.some(bc => bc.cardId === targetCardId);
  const onOpponentBoard = opponentBoard.some(bc => bc.cardId === targetCardId);

  if (!onHostBoard && !onOpponentBoard) {
    return { success: false, message: "Target not found on field" };
  }

  // Determine which board and graveyard
  const targetIsHost = onHostBoard;
  const targetOwnerId = targetIsHost ? gameState.hostId : gameState.opponentId;
  const board = targetIsHost ? hostBoard : opponentBoard;
  const graveyard = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;

  // Check for "Cannot be destroyed by effects" protection
  const boardCard = board.find(bc => bc.cardId === targetCardId);
  if (boardCard?.cannotBeDestroyedByEffects) {
    const card = await ctx.db.get(targetCardId);
    return {
      success: false,
      message: `${card?.name || "Card"} cannot be destroyed by card effects`
    };
  }

  // Get card details for trigger check
  const card = await ctx.db.get(targetCardId);

  // Check for "When destroyed" trigger effects BEFORE moving to graveyard
  if (card?.ability) {
    const parsedEffect = parseAbility(card.ability);

    if (parsedEffect && parsedEffect.trigger === "on_destroy") {
      const effectResult = await executeEffect(
        ctx,
        gameState,
        lobbyId,
        parsedEffect,
        targetOwnerId,
        targetCardId,
        []
      );

      if (effectResult.success) {
        const lobby = await ctx.db.get(lobbyId);
        const owner = await ctx.db.get(targetOwnerId);

        await ctx.runMutation(api.gameEvents.recordEvent, {
          lobbyId,
          gameId: lobby?.gameId || "",
          turnNumber: lobby?.turnNumber || 0,
          eventType: "effect_activated",
          playerId: targetOwnerId,
          playerUsername: owner?.username || "Unknown",
          description: `${card.name} on-destroy effect: ${effectResult.message}`,
          metadata: { cardId: targetCardId, trigger: "on_destroy" },
        });
      }
    }
  }

  // Remove from board
  const newBoard = board.filter(bc => bc.cardId !== targetCardId);

  // Add to graveyard
  const newGraveyard = [...graveyard, targetCardId];

  await ctx.db.patch(gameState._id, {
    [targetIsHost ? "hostBoard" : "opponentBoard"]: newBoard,
    [targetIsHost ? "hostGraveyard" : "opponentGraveyard"]: newGraveyard,
  });

  // Record event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(playerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "card_to_graveyard",
    playerId,
    playerUsername: user?.username || "Unknown",
    description: `${card?.name || "Card"} was destroyed by card effect`,
    metadata: { cardId: targetCardId, reason: "effect_destroy" },
  });

  return { success: true, message: `Destroyed ${card?.name || "target"}` };
}

async function executeDamage(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetPlayerId: Id<"users">,
  damage: number
): Promise<{ success: boolean; message: string }> {

  const isHost = targetPlayerId === gameState.hostId;
  const currentLP = isHost ? gameState.hostLifePoints : gameState.opponentLifePoints;
  const newLP = Math.max(0, currentLP - damage);

  await ctx.db.patch(gameState._id, {
    [isHost ? "hostLifePoints" : "opponentLifePoints"]: newLP,
  });

  // Record LP change event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(targetPlayerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "lp_changed",
    playerId: targetPlayerId,
    playerUsername: user?.username || "Unknown",
    description: `${user?.username} takes ${damage} damage (${currentLP} -> ${newLP} LP)`,
    metadata: { previousLP: currentLP, newLP, change: -damage },
  });

  // Check for game end
  if (newLP <= 0) {
    return { success: true, message: `Dealt ${damage} damage - GAME OVER` };
  }

  return { success: true, message: `Dealt ${damage} damage` };
}

async function executeGainLP(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetPlayerId: Id<"users">,
  amount: number
): Promise<{ success: boolean; message: string }> {

  const isHost = targetPlayerId === gameState.hostId;
  const currentLP = isHost ? gameState.hostLifePoints : gameState.opponentLifePoints;
  const newLP = currentLP + amount;

  await ctx.db.patch(gameState._id, {
    [isHost ? "hostLifePoints" : "opponentLifePoints"]: newLP,
  });

  // Record LP change event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(targetPlayerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "lp_changed",
    playerId: targetPlayerId,
    playerUsername: user?.username || "Unknown",
    description: `${user?.username} gains ${amount} LP (${currentLP} -> ${newLP} LP)`,
    metadata: { previousLP: currentLP, newLP, change: amount },
  });

  return { success: true, message: `Gained ${amount} LP` };
}

/**
 * Execute "Add to Hand" effect
 * Moves a card from graveyard (or other zone) to hand
 */
async function executeToHand(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">,
  sourceLocation: "graveyard" | "hand" | "board" | "deck"
): Promise<{ success: boolean; message: string }> {

  const isHost = playerId === gameState.hostId;
  const hand = isHost ? gameState.hostHand : gameState.opponentHand;
  const graveyard = isHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
  const board = isHost ? gameState.hostBoard : gameState.opponentBoard;
  const opponentBoard = isHost ? gameState.opponentBoard : gameState.hostBoard;
  const opponentHand = isHost ? gameState.opponentHand : gameState.hostHand;

  // Get card details
  const card = await ctx.db.get(targetCardId);
  if (!card) {
    return { success: false, message: "Card not found" };
  }

  let newHand = hand;
  let targetOwnerIsHost = isHost;
  let description = "";

  if (sourceLocation === "graveyard") {
    // Add from graveyard to hand (own card)
    if (!graveyard.includes(targetCardId)) {
      return { success: false, message: "Card not found in graveyard" };
    }

    const newGraveyard = graveyard.filter((c) => c !== targetCardId);
    newHand = [...hand, targetCardId];

    await ctx.db.patch(gameState._id, {
      [isHost ? "hostGraveyard" : "opponentGraveyard"]: newGraveyard,
      [isHost ? "hostHand" : "opponentHand"]: newHand,
    });

    description = `${card.name} added from graveyard to hand`;
  } else if (sourceLocation === "board") {
    // Return card from board to hand (bounce effect)
    // Check own board first
    const onOwnBoard = board.find((bc) => bc.cardId === targetCardId);
    const onOpponentBoard = opponentBoard.find((bc) => bc.cardId === targetCardId);

    if (onOwnBoard) {
      // Return own card to own hand
      const newBoard = board.filter((bc) => bc.cardId !== targetCardId);
      newHand = [...hand, targetCardId];

      await ctx.db.patch(gameState._id, {
        [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
        [isHost ? "hostHand" : "opponentHand"]: newHand,
      });

      description = `${card.name} returned to hand`;
    } else if (onOpponentBoard) {
      // Return opponent's card to opponent's hand
      const newOpponentBoard = opponentBoard.filter((bc) => bc.cardId !== targetCardId);
      const newOpponentHand = [...opponentHand, targetCardId];
      targetOwnerIsHost = !isHost;

      await ctx.db.patch(gameState._id, {
        [isHost ? "opponentBoard" : "hostBoard"]: newOpponentBoard,
        [isHost ? "opponentHand" : "hostHand"]: newOpponentHand,
      });

      description = `${card.name} returned to opponent's hand`;
    } else {
      return { success: false, message: "Card not found on field" };
    }
  } else {
    return { success: false, message: `Cannot add from ${sourceLocation} yet` };
  }

  // Record card_to_hand event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(playerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "card_to_hand",
    playerId,
    playerUsername: user?.username || "Unknown",
    description,
    metadata: {
      cardId: targetCardId,
      cardName: card.name,
      sourceLocation,
    },
  });

  return { success: true, message: description };
}

async function executeModifyATK(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  targetCardId: Id<"cardDefinitions">,
  modifier: number,
  isHost: boolean
): Promise<{ success: boolean; message: string }> {

  const board = isHost ? gameState.hostBoard : gameState.opponentBoard;
  const cardIndex = board.findIndex(bc => bc.cardId === targetCardId);

  if (cardIndex === -1) {
    return { success: false, message: "Target not found on field" };
  }

  const card = board[cardIndex]!;
  const newBoard = [...board];
  newBoard[cardIndex] = {
    ...card,
    attack: Math.max(0, card.attack + modifier),
  };

  await ctx.db.patch(gameState._id, {
    [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
  });

  const cardDef = await ctx.db.get(targetCardId);
  return {
    success: true,
    message: `${cardDef?.name || "Target"} ATK ${modifier > 0 ? "increased" : "decreased"} by ${Math.abs(modifier)}`
  };
}

async function executeSpecialSummon(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">,
  fromLocation: "hand" | "graveyard" | "deck" | "board"
): Promise<{ success: boolean; message: string }> {

  const isHost = playerId === gameState.hostId;
  const board = isHost ? gameState.hostBoard : gameState.opponentBoard;

  // Check board space (max 5)
  if (board.length >= 5) {
    return { success: false, message: "Monster zone is full" };
  }

  // Get card details
  const card = await ctx.db.get(targetCardId);
  if (!card) {
    return { success: false, message: "Card not found" };
  }

  // Validate it's a monster
  if (card.cardType !== "creature") {
    return { success: false, message: "Can only summon monsters" };
  }

  // Remove from source location
  let sourceZone: Id<"cardDefinitions">[] = [];
  if (fromLocation === "hand") {
    sourceZone = isHost ? gameState.hostHand : gameState.opponentHand;
  } else if (fromLocation === "graveyard") {
    sourceZone = isHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
  } else {
    return { success: false, message: `Cannot summon from ${fromLocation}` };
  }

  if (!sourceZone.includes(targetCardId)) {
    return { success: false, message: `Card not found in ${fromLocation}` };
  }

  const newSourceZone = sourceZone.filter(c => c !== targetCardId);

  // Add to board
  const newBoardCard = {
    cardId: targetCardId,
    position: 1, // Attack position
    attack: card.attack || 0,
    defense: card.defense || 0,
    hasAttacked: true, // Cannot attack turn it's special summoned (simplified)
    isFaceDown: false,
  };

  const newBoard = [...board, newBoardCard];

  // Update state
  await ctx.db.patch(gameState._id, {
    [isHost ? "hostBoard" : "opponentBoard"]: newBoard,
    [fromLocation === "hand"
      ? (isHost ? "hostHand" : "opponentHand")
      : (isHost ? "hostGraveyard" : "opponentGraveyard")]: newSourceZone,
  });

  return { success: true, message: `Special Summoned ${card.name} from ${fromLocation}` };
}

/**
 * Execute Search effect - Search deck for cards matching criteria
 *
 * @param ctx - Mutation context
 * @param gameState - Current game state
 * @param playerId - Player searching their deck
 * @param effect - Parsed search effect with targetType, targetCount, condition
 * @param selectedCardId - Optional: Card selected from search results
 * @returns Success status, message, and matching cards if no selection made yet
 */
async function executeSearch(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  playerId: Id<"users">,
  effect: ParsedEffect,
  selectedCardId?: Id<"cardDefinitions">
): Promise<{ success: boolean; message: string; matchingCards?: Id<"cardDefinitions">[] }> {
  const isHost = gameState.hostId === playerId;
  const deck = isHost ? gameState.hostDeck : gameState.opponentDeck;

  if (deck.length === 0) {
    return { success: false, message: "Deck is empty" };
  }

  // Get target type and count from effect
  const targetType = effect.targetType || "any";
  const targetCount = effect.targetCount || 1;
  const archetype = effect.condition?.replace("_search", "");

  // Filter deck by target type and archetype
  const matchingCards: Id<"cardDefinitions">[] = [];

  for (const cardId of deck) {
    const card = await ctx.db.get(cardId);
    if (!card) continue;

    // Check type filter
    let typeMatch = false;
    if (targetType === "any") {
      typeMatch = true;
    } else if (targetType === "monster") {
      typeMatch = card.cardType === "creature"; // "creature" in schema = "monster" in game
    } else if (targetType === "spell") {
      typeMatch = card.cardType === "spell";
    } else if (targetType === "trap") {
      typeMatch = card.cardType === "trap";
    }

    if (!typeMatch) continue;

    // Check archetype filter (if specified)
    if (archetype) {
      const cardArchetype = card.archetype?.toLowerCase() || "";
      const cardName = card.name.toLowerCase();

      // Match if archetype matches card's archetype field OR is in the card name
      if (cardArchetype.includes(archetype) || cardName.includes(archetype)) {
        matchingCards.push(cardId);
      }
    } else {
      // No archetype filter, just type match
      matchingCards.push(cardId);
    }

    // Stop if we've found enough matches
    if (matchingCards.length >= targetCount * 3) break; // Get 3x target for selection pool
  }

  // If no matches found
  if (matchingCards.length === 0) {
    const archetypeText = archetype ? ` ${archetype}` : "";
    const typeText = targetType === "any" ? "card" : targetType;
    return { success: false, message: `No${archetypeText} ${typeText}s found in deck` };
  }

  // If no card selected yet, return matching cards for selection
  if (!selectedCardId) {
    return {
      success: true,
      message: `Found ${matchingCards.length} matching card(s)`,
      matchingCards: matchingCards.slice(0, 10), // Return up to 10 for selection
    };
  }

  // Validate selected card is in matching cards
  if (!matchingCards.includes(selectedCardId)) {
    return { success: false, message: "Selected card does not match search criteria" };
  }

  // Move selected card from deck to hand
  const newDeck = deck.filter((c) => c !== selectedCardId);
  const hand = isHost ? gameState.hostHand : gameState.opponentHand;
  const newHand = [...hand, selectedCardId];

  // Shuffle deck (simplified - just update the deck without actual shuffle for now)
  await ctx.db.patch(gameState._id, {
    [isHost ? "hostDeck" : "opponentDeck"]: newDeck,
    [isHost ? "hostHand" : "opponentHand"]: newHand,
  });

  const card = await ctx.db.get(selectedCardId);
  const cardName = card?.name || "Unknown card";

  return { success: true, message: `Added ${cardName} from deck to hand` };
}

/**
 * Execute Negate effect - Negate activation or effect of a card
 *
 * @param ctx - Mutation context
 * @param gameState - Current game state
 * @param targetCardId - Card being negated
 * @param effect - Parsed negate effect with condition (activation or effect)
 * @returns Success status and message
 *
 * Note: Full negation requires chain system implementation.
 * For now, this provides basic negation detection and parsing.
 * In a complete implementation:
 * - Negation would be added to the chain
 * - The target activation would be negated before resolving
 * - Negated cards would be sent to GY (for activation negation)
 */
async function executeNegate(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  targetCardId: Id<"cardDefinitions">,
  effect: ParsedEffect
): Promise<{ success: boolean; message: string }> {
  // Get target card
  const targetCard = await ctx.db.get(targetCardId);
  if (!targetCard) {
    return { success: false, message: "Target card not found" };
  }

  // Validate target type matches effect
  if (effect.targetType && effect.targetType !== "any") {
    const cardTypeMap: Record<string, string> = {
      creature: "monster",
      spell: "spell",
      trap: "trap",
      equipment: "spell", // Treat equipment as spell for negation purposes
    };
    const cardGameType = cardTypeMap[targetCard.cardType] || "unknown";

    if (cardGameType !== effect.targetType) {
      return {
        success: false,
        message: `Can only negate ${effect.targetType} cards (target is ${cardGameType})`,
      };
    }
  }

  // Determine negation type
  const isActivationNegate = effect.condition === "activation";
  const negationType = isActivationNegate ? "activation" : "effect";

  // In a full implementation, this would:
  // 1. Check if target card is currently activating (on chain)
  // 2. Remove it from the chain
  // 3. Send to GY if activation negation
  // 4. Record negate event

  // For now, return success with message indicating what was negated
  return {
    success: true,
    message: `Negated ${negationType} of ${targetCard.name}`,
  };
}

/**
 * Execute Banish effect - Remove card from play to banished zone
 *
 * @param ctx - Mutation context
 * @param gameState - Current game state
 * @param targetCardId - Card to banish
 * @param playerId - Player activating the effect
 * @param fromLocation - Source location (board, graveyard, hand, deck)
 * @returns Success status and message
 */
async function executeBanish(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">,
  fromLocation: "board" | "graveyard" | "hand" | "deck" = "board"
): Promise<{ success: boolean; message: string }> {
  const isHost = playerId === gameState.hostId;

  // Get card details
  const card = await ctx.db.get(targetCardId);
  if (!card) {
    return { success: false, message: "Target card not found" };
  }

  // Determine which player owns the card
  let sourceZone: Id<"cardDefinitions">[];
  let sourceField: string;
  let targetIsHost = isHost;

  // Find card in specified location
  if (fromLocation === "board") {
    const onHostBoard = gameState.hostBoard.some(bc => bc.cardId === targetCardId);
    const onOpponentBoard = gameState.opponentBoard.some(bc => bc.cardId === targetCardId);

    if (!onHostBoard && !onOpponentBoard) {
      return { success: false, message: "Card not found on field" };
    }

    targetIsHost = onHostBoard;
    sourceZone = targetIsHost
      ? gameState.hostBoard.map(bc => bc.cardId)
      : gameState.opponentBoard.map(bc => bc.cardId);
    sourceField = targetIsHost ? "hostBoard" : "opponentBoard";
  } else if (fromLocation === "graveyard") {
    const inHostGY = gameState.hostGraveyard.includes(targetCardId);
    const inOpponentGY = gameState.opponentGraveyard.includes(targetCardId);

    if (!inHostGY && !inOpponentGY) {
      return { success: false, message: "Card not found in graveyard" };
    }

    targetIsHost = inHostGY;
    sourceZone = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
    sourceField = targetIsHost ? "hostGraveyard" : "opponentGraveyard";
  } else if (fromLocation === "hand") {
    const inHostHand = gameState.hostHand.includes(targetCardId);
    const inOpponentHand = gameState.opponentHand.includes(targetCardId);

    if (!inHostHand && !inOpponentHand) {
      return { success: false, message: "Card not found in hand" };
    }

    targetIsHost = inHostHand;
    sourceZone = targetIsHost ? gameState.hostHand : gameState.opponentHand;
    sourceField = targetIsHost ? "hostHand" : "opponentHand";
  } else {
    // deck
    const inHostDeck = gameState.hostDeck.includes(targetCardId);
    const inOpponentDeck = gameState.opponentDeck.includes(targetCardId);

    if (!inHostDeck && !inOpponentDeck) {
      return { success: false, message: "Card not found in deck" };
    }

    targetIsHost = inHostDeck;
    sourceZone = targetIsHost ? gameState.hostDeck : gameState.opponentDeck;
    sourceField = targetIsHost ? "hostDeck" : "opponentDeck";
  }

  // Remove from source zone
  const newSourceZone = fromLocation === "board"
    ? (targetIsHost ? gameState.hostBoard : gameState.opponentBoard).filter(bc => bc.cardId !== targetCardId)
    : sourceZone.filter(c => c !== targetCardId);

  // Add to banished zone
  const banishedZone = targetIsHost ? gameState.hostBanished : gameState.opponentBanished;
  const newBanishedZone = [...banishedZone, targetCardId];

  // Update game state
  await ctx.db.patch(gameState._id, {
    [sourceField]: fromLocation === "board" ? newSourceZone : newSourceZone,
    [targetIsHost ? "hostBanished" : "opponentBanished"]: newBanishedZone,
  });

  return { success: true, message: `Banished ${card.name} from ${fromLocation}` };
}

/**
 * Execute Send to Graveyard effect - Move card to GY without triggering destroy effects
 *
 * Different from destroy:
 * - Bypasses "cannot be destroyed by effects" protection
 * - Does NOT trigger "when destroyed" effects
 * - Direct send without destruction
 *
 * @param ctx - Mutation context
 * @param gameState - Current game state
 * @param lobbyId - Lobby ID for events
 * @param targetCardId - Card to send to graveyard
 * @param playerId - Player activating the effect
 * @param fromLocation - Source location (board, hand, deck)
 * @returns Success status and message
 */
async function executeSendToGraveyard(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">,
  fromLocation: "board" | "hand" | "deck" = "board"
): Promise<{ success: boolean; message: string }> {
  const isHost = playerId === gameState.hostId;

  // Get card details
  const card = await ctx.db.get(targetCardId);
  if (!card) {
    return { success: false, message: "Target card not found" };
  }

  // Determine which player owns the card and source location
  let sourceZone: Id<"cardDefinitions">[];
  let sourceField: string;
  let targetIsHost = isHost;
  let graveyardField: string;

  if (fromLocation === "board") {
    const onHostBoard = gameState.hostBoard.some(bc => bc.cardId === targetCardId);
    const onOpponentBoard = gameState.opponentBoard.some(bc => bc.cardId === targetCardId);

    if (!onHostBoard && !onOpponentBoard) {
      return { success: false, message: "Card not found on field" };
    }

    targetIsHost = onHostBoard;
    sourceField = targetIsHost ? "hostBoard" : "opponentBoard";
    graveyardField = targetIsHost ? "hostGraveyard" : "opponentGraveyard";

    // Remove from board
    const board = targetIsHost ? gameState.hostBoard : gameState.opponentBoard;
    const newBoard = board.filter(bc => bc.cardId !== targetCardId);

    // Add to graveyard
    const graveyard = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
    const newGraveyard = [...graveyard, targetCardId];

    await ctx.db.patch(gameState._id, {
      [sourceField]: newBoard,
      [graveyardField]: newGraveyard,
    });
  } else if (fromLocation === "hand") {
    const inHostHand = gameState.hostHand.includes(targetCardId);
    const inOpponentHand = gameState.opponentHand.includes(targetCardId);

    if (!inHostHand && !inOpponentHand) {
      return { success: false, message: "Card not found in hand" };
    }

    targetIsHost = inHostHand;
    sourceField = targetIsHost ? "hostHand" : "opponentHand";
    graveyardField = targetIsHost ? "hostGraveyard" : "opponentGraveyard";

    // Remove from hand
    const hand = targetIsHost ? gameState.hostHand : gameState.opponentHand;
    const newHand = hand.filter(c => c !== targetCardId);

    // Add to graveyard
    const graveyard = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
    const newGraveyard = [...graveyard, targetCardId];

    await ctx.db.patch(gameState._id, {
      [sourceField]: newHand,
      [graveyardField]: newGraveyard,
    });
  } else {
    // deck
    const inHostDeck = gameState.hostDeck.includes(targetCardId);
    const inOpponentDeck = gameState.opponentDeck.includes(targetCardId);

    if (!inHostDeck && !inOpponentDeck) {
      return { success: false, message: "Card not found in deck" };
    }

    targetIsHost = inHostDeck;
    sourceField = targetIsHost ? "hostDeck" : "opponentDeck";
    graveyardField = targetIsHost ? "hostGraveyard" : "opponentGraveyard";

    // Remove from deck
    const deck = targetIsHost ? gameState.hostDeck : gameState.opponentDeck;
    const newDeck = deck.filter(c => c !== targetCardId);

    // Add to graveyard
    const graveyard = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
    const newGraveyard = [...graveyard, targetCardId];

    await ctx.db.patch(gameState._id, {
      [sourceField]: newDeck,
      [graveyardField]: newGraveyard,
    });
  }

  // Record event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(playerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "card_to_graveyard",
    playerId: playerId,
    playerUsername: user?.username || "Unknown",
    description: `Sent ${card.name} from ${fromLocation} to graveyard`,
    metadata: { cardId: targetCardId, fromLocation },
  });

  return { success: true, message: `Sent ${card.name} from ${fromLocation} to graveyard` };
}

/**
 * Execute Return to Deck effect - Return card from field/hand/GY to deck
 *
 * @param ctx - Mutation context
 * @param gameState - Current game state
 * @param lobbyId - Lobby ID for events
 * @param targetCardId - Card to return to deck
 * @param playerId - Player activating the effect
 * @param fromLocation - Source location (board, hand, graveyard)
 * @param position - Where to place in deck (top, bottom, shuffle)
 * @returns Success status and message
 */
async function executeReturnToDeck(
  ctx: MutationCtx,
  gameState: Doc<"gameStates">,
  lobbyId: Id<"gameLobbies">,
  targetCardId: Id<"cardDefinitions">,
  playerId: Id<"users">,
  fromLocation: "board" | "hand" | "graveyard" = "board",
  position: "top" | "bottom" | "shuffle" = "shuffle"
): Promise<{ success: boolean; message: string }> {
  const isHost = playerId === gameState.hostId;

  // Get card details
  const card = await ctx.db.get(targetCardId);
  if (!card) {
    return { success: false, message: "Target card not found" };
  }

  // Determine which player owns the card
  let targetIsHost = isHost;
  let sourceField: string;
  let deckField: string;

  if (fromLocation === "board") {
    const onHostBoard = gameState.hostBoard.some(bc => bc.cardId === targetCardId);
    const onOpponentBoard = gameState.opponentBoard.some(bc => bc.cardId === targetCardId);

    if (!onHostBoard && !onOpponentBoard) {
      return { success: false, message: "Card not found on field" };
    }

    targetIsHost = onHostBoard;
    sourceField = targetIsHost ? "hostBoard" : "opponentBoard";
    deckField = targetIsHost ? "hostDeck" : "opponentDeck";

    // Remove from board
    const board = targetIsHost ? gameState.hostBoard : gameState.opponentBoard;
    const newBoard = board.filter(bc => bc.cardId !== targetCardId);

    // Add to deck at specified position
    const deck = targetIsHost ? gameState.hostDeck : gameState.opponentDeck;
    let newDeck: Id<"cardDefinitions">[];

    if (position === "top") {
      newDeck = [targetCardId, ...deck];
    } else if (position === "bottom") {
      newDeck = [...deck, targetCardId];
    } else {
      // shuffle - just add and treat as shuffled (simplified)
      newDeck = [...deck, targetCardId];
    }

    await ctx.db.patch(gameState._id, {
      [sourceField]: newBoard,
      [deckField]: newDeck,
    });
  } else if (fromLocation === "hand") {
    const inHostHand = gameState.hostHand.includes(targetCardId);
    const inOpponentHand = gameState.opponentHand.includes(targetCardId);

    if (!inHostHand && !inOpponentHand) {
      return { success: false, message: "Card not found in hand" };
    }

    targetIsHost = inHostHand;
    sourceField = targetIsHost ? "hostHand" : "opponentHand";
    deckField = targetIsHost ? "hostDeck" : "opponentDeck";

    // Remove from hand
    const hand = targetIsHost ? gameState.hostHand : gameState.opponentHand;
    const newHand = hand.filter(c => c !== targetCardId);

    // Add to deck at specified position
    const deck = targetIsHost ? gameState.hostDeck : gameState.opponentDeck;
    let newDeck: Id<"cardDefinitions">[];

    if (position === "top") {
      newDeck = [targetCardId, ...deck];
    } else if (position === "bottom") {
      newDeck = [...deck, targetCardId];
    } else {
      newDeck = [...deck, targetCardId];
    }

    await ctx.db.patch(gameState._id, {
      [sourceField]: newHand,
      [deckField]: newDeck,
    });
  } else {
    // graveyard
    const inHostGY = gameState.hostGraveyard.includes(targetCardId);
    const inOpponentGY = gameState.opponentGraveyard.includes(targetCardId);

    if (!inHostGY && !inOpponentGY) {
      return { success: false, message: "Card not found in graveyard" };
    }

    targetIsHost = inHostGY;
    sourceField = targetIsHost ? "hostGraveyard" : "opponentGraveyard";
    deckField = targetIsHost ? "hostDeck" : "opponentDeck";

    // Remove from graveyard
    const graveyard = targetIsHost ? gameState.hostGraveyard : gameState.opponentGraveyard;
    const newGraveyard = graveyard.filter(c => c !== targetCardId);

    // Add to deck at specified position
    const deck = targetIsHost ? gameState.hostDeck : gameState.opponentDeck;
    let newDeck: Id<"cardDefinitions">[];

    if (position === "top") {
      newDeck = [targetCardId, ...deck];
    } else if (position === "bottom") {
      newDeck = [...deck, targetCardId];
    } else {
      newDeck = [...deck, targetCardId];
    }

    await ctx.db.patch(gameState._id, {
      [sourceField]: newGraveyard,
      [deckField]: newDeck,
    });
  }

  // Record event
  const lobby = await ctx.db.get(lobbyId);
  const user = await ctx.db.get(playerId);

  await ctx.runMutation(api.gameEvents.recordEvent, {
    lobbyId,
    gameId: lobby?.gameId || "",
    turnNumber: lobby?.turnNumber || 0,
    eventType: "effect_activated",
    playerId: playerId,
    playerUsername: user?.username || "Unknown",
    description: `Returned ${card.name} from ${fromLocation} to deck (${position})`,
    metadata: { cardId: targetCardId, fromLocation, position, effectType: "return_to_deck" },
  });

  const positionText = position === "shuffle" ? "and shuffled" : `(${position})`;
  return { success: true, message: `Returned ${card.name} from ${fromLocation} to deck ${positionText}` };
}
