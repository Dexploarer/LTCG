/**
 * Tests for lib/validators.ts
 *
 * Tests centralized validation functions including:
 * - Session validation
 * - Card ownership checks
 * - Currency record management
 * - Transaction recording
 */

import { describe, it, expect, beforeEach } from "vitest";
import { createTestInstance } from "../test_utils/setup";
import type { TestMutationCtx } from "../test_utils/setup";
import { api } from "../_generated/api";
import { Id } from "../_generated/dataModel";


describe("Convex Auth Integration", () => {
  it("should return empty array when user has no cards", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      return await ctx.db.insert("users", {
        username: "testuser",
        email: "test@example.com",
        createdAt: Date.now(),
      });
    });

    const asUser = t.withIdentity({ subject: userId });
    const cards = await asUser.query(api.cards.getUserCards, {});
    expect(cards).toEqual([]);
  });

  it("should throw error when not authenticated", async () => {
    const t = createTestInstance();

    await expect(
      t.query(api.cards.getUserCards, {})
    ).rejects.toThrowError();
  });
});

describe("checkCardOwnership", () => {
  it("should return false when user does not own card", async () => {
    const t = createTestInstance();

    const [userId, cardDefId] = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "testuser",
        email: "test@example.com",
        createdAt: Date.now(),
      });

      const cid = await ctx.db.insert("cardDefinitions", {
        name: "Test Card",
        rarity: "common",
        archetype: "fire",
        cardType: "creature",
        cost: 3,
        isActive: true,
        createdAt: Date.now(),
      });

      return [uid, cid];
    });

    const asUser = t.withIdentity({ subject: userId });

    // User doesn't own the card - marketplace should reject listing
    await expect(
      asUser.mutation(api.marketplace.createListing, {
        cardDefinitionId: cardDefId,
        quantity: 1,
        listingType: "fixed",
        price: 100,
      })
    ).rejects.toThrowError("You don't own enough of this card");
  });

  it("should return true when user owns sufficient quantity", async () => {
    const t = createTestInstance();

    const [userId, cardDefId] = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "testuser",
        email: "test@example.com",
        createdAt: Date.now(),
      });

      const cid = await ctx.db.insert("cardDefinitions", {
        name: "Test Card",
        rarity: "common",
        archetype: "fire",
        cardType: "creature",
        cost: 3,
        isActive: true,
        createdAt: Date.now(),
      });

      // Give user 5 cards
      await ctx.db.insert("playerCards", {
        userId: uid,
        cardDefinitionId: cid,
        quantity: 5,
        isFavorite: false,
        acquiredAt: Date.now(),
        lastUpdatedAt: Date.now(),
      });

      return [uid, cid];
    });

    const asUser = t.withIdentity({ subject: userId });

    // Should succeed - user owns 5, trying to list 3
    const result = await asUser.mutation(api.marketplace.createListing, {
      cardDefinitionId: cardDefId,
      quantity: 3,
      listingType: "fixed",
      price: 100,
    });

    expect(result.success).toBe(true);
    expect(result.listingId).toBeDefined();
  });
});

describe("getOrCreatePlayerCurrency", () => {
  it("should return existing currency record", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "testuser",
        email: "test@example.com",
        createdAt: Date.now(),
      });

      await ctx.db.insert("playerCurrency", {
        userId: uid,
        gold: 1000,
        gems: 50,
        lifetimeGoldEarned: 1000,
        lifetimeGoldSpent: 0,
        lifetimeGemsEarned: 50,
        lifetimeGemsSpent: 0,
        lastUpdatedAt: Date.now(),
      });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });
    const balance = await asUser.query(api.economy.getPlayerBalance, {});

    expect(balance.gold).toBe(1000);
    expect(balance.gems).toBe(50);
  });

  it("should return currency record for new user", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "newuser",
        email: "new@example.com",
        createdAt: Date.now(),
      });

      await ctx.db.insert("playerCurrency", {
        userId: uid,
        gold: 0,
        gems: 0,
        lifetimeGoldEarned: 0,
        lifetimeGoldSpent: 0,
        lifetimeGemsEarned: 0,
        lifetimeGemsSpent: 0,
        lastUpdatedAt: Date.now(),
      });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });
    const balance = await asUser.query(api.economy.getPlayerBalance, {});

    // Should have 0 values
    expect(balance.gold).toBe(0);
    expect(balance.gems).toBe(0);
    expect(balance.lifetimeStats.goldEarned).toBe(0);
  });
});

describe("recordTransaction", () => {
  it("should record transaction in ledger", async () => {
    const t = createTestInstance();

    const userId = await t.run(async (ctx: TestMutationCtx) => {
      const uid = await ctx.db.insert("users", {
        username: "testuser",
        email: "test@example.com",
        createdAt: Date.now(),
      });

      await ctx.db.insert("playerCurrency", {
        userId: uid,
        gold: 500,
        gems: 100,
        lifetimeGoldEarned: 500,
        lifetimeGoldSpent: 0,
        lifetimeGemsEarned: 100,
        lifetimeGemsSpent: 0,
        lastUpdatedAt: Date.now(),
      });

      await ctx.db.insert("promoCodes", {
        code: "TEST100",
        description: "Test promo code",
        rewardType: "gold",
        rewardAmount: 100,
        isActive: true,
        redemptionCount: 0,
        createdAt: Date.now(),
      });

      return uid;
    });

    const asUser = t.withIdentity({ subject: userId });

    await asUser.mutation(api.economy.redeemPromoCode, {
      code: "TEST100",
    });

    // Check transaction was recorded
    const history = await asUser.query(api.economy.getTransactionHistory, {});

    expect(history.transactions.length).toBeGreaterThan(0);
    expect(history.transactions[0]).toMatchObject({
      transactionType: "gift",
      currencyType: "gold",
      amount: 100,
    });
  });
});
